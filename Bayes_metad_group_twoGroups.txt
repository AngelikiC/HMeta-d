# Bayesian estimation of meta-d for two groups

data {
    for (s in 1:nsubj) {
        # Type 1 counts
        N[s] <- sum(counts[s,1:nratings*2])
        S[s] <- sum(counts[s,(nratings*2)+1:nratings*4])
        H[s] <- sum(counts[s,(nratings*3)+1:nratings*4])
        FA[s] <- sum(counts[s,(nratings*2)+1:nratings*3])
        M[s] <- sum(counts[s,nratings+1:nratings*2])
        CR[s] <- sum(counts[s,1:nratings])
    }
}

model {
  for (s in 1:nsubj) {

    ## TYPE 1 SDT BINOMIAL MODEL
    H[s] ~ dbin(h[s],S[s])
    FA[s] ~ dbin(f[s],N[s])
    h[s] <- phi(d1[s]/2-c[s])
    f[s] <- phi(-d1[s]/2-c[s])

    # Type 1 priors
    c[s] ~ dnorm(mu_c[grpind[s]], lambda_c[grpind[s]])
    d1[s] ~ dnorm(mu_d1[grpind[s]], lambda_d1[grpind[s]])

    ## TYPE 2 SDT MODEL (META-D)
	# Multinomial likelihood for response counts ordered as c(nR_S1,nR_S2)
    counts[s,1:nratings] ~ dmulti(prT[s,1:nratings],CR[s])
    counts[s,nratings+1:nratings*2] ~ dmulti(prT[s,nratings+1:nratings*2],M[s])
    counts[s,(nratings*2)+1:nratings*3] ~ dmulti(prT[s,(nratings*2)+1:nratings*3],FA[s])
    counts[s,(nratings*3)+1:nratings*4] ~ dmulti(prT[s,(nratings*3)+1:nratings*4],H[s])

	# Means of SDT distributions]
	mu[s] <- Mratio[s]*d1[s]
	S2mu[s] <- mu[s]/2
	S1mu[s] <- -mu[s]/2

	# Calculate normalisation constants
	C_area_rS1[s] <- phi(c[s] - S1mu[s])
	I_area_rS1[s] <- phi(c[s] - S2mu[s])
	C_area_rS2[s] <- 1-phi(c[s] - S2mu[s])
	I_area_rS2[s] <- 1-phi(c[s] - S1mu[s])

	# Get nC_rS1 probs
	pr[s,1] <- phi(cS1[s,1] - S1mu[s])/C_area_rS1[s]  
	for (k in 1:nratings-2) {                
  		pr[s,k+1] <- (phi(cS1[s,k+1] - S1mu[s])-phi(cS1[s,k] - S1mu[s]))/C_area_rS1[s]
	}
	pr[s,nratings] <- (phi(c[s] - S1mu[s])-phi(cS1[s,nratings-1] - S1mu[s]))/C_area_rS1[s]   

	# Get nI_rS2 probs
	pr[s,nratings+1] <- ((1-phi(c[s] - S1mu[s]))-(1-phi(cS2[s,1] - S1mu[s])))/I_area_rS2[s]
	for (k in 1:nratings-2) {                
  		pr[s,nratings+1+k] <- ((1-phi(cS2[s,k] - S1mu[s]))-(1-phi(cS2[s,k+1] - S1mu[s])))/I_area_rS2[s]
	}
	pr[s,nratings*2] <- (1-phi(cS2[s,nratings-1] - S1mu[s]))/I_area_rS2[s]

	# Get nI_rS1 probs
	pr[s,(nratings*2)+1] <- phi(cS1[s,1] - S2mu[s])/I_area_rS1[s]
	for (k in 1:nratings-2) {
  		pr[s,(nratings*2)+1+k] <- (phi(cS1[s,k+1] - S2mu[s])-phi(cS1[s,k] - S2mu[s]))/I_area_rS1[s]
	}
	pr[s,nratings*3] <- (phi(c[s] - S2mu[s])-phi(cS1[s,nratings-1] - S2mu[s]))/I_area_rS1[s]

	# Get nC_rS2 probs
	pr[s,(nratings*3)+1] <- ((1-phi(c[s] - S2mu[s]))-(1-phi(cS2[s,1] - S2mu[s])))/C_area_rS2[s]
	for (k in 1:nratings-2) {                
  		pr[s,(nratings*3)+1+k] <- ((1-phi(cS2[s,k] - S2mu[s]))-(1-phi(cS2[s,k+1] - S2mu[s])))/C_area_rS2[s]
	}
	pr[s,nratings*4] <- (1-phi(cS2[s,nratings-1] - S2mu[s]))/C_area_rS2[s]

	# Avoid underflow of probabilities
	for (i in 1:nratings*4) {
  		prT[s,i] <- ifelse(pr[s,i] < Tol, Tol, pr[s,i])
	}

	# Specify ordered prior on criteria (bounded above and below by Type 1 c) 
	for (j in 1:nratings-1) {
        cS1_raw[s,j] ~ dnorm(mu_cS1[grpind[s]], lambda_cS1[grpind[s]])
        cS2_raw[s,j] ~ dnorm(mu_cS2[grpind[s]], lambda_cS2[grpind[s]])
	}
	cS1[s,1:nratings-1] <- sort(cS1_raw[s, ])
	cS2[s,1:nratings-1] <- sort(cS2_raw[s, ])

    delta[s] ~ dnorm(0, lambda_delta[grpind[s]])
    Mratio[s] <- mu_Mratio[grpind[s]] + epsilon_Mratio[grpind[s]]*delta[grpind[s]]

    }
	
    for (g in 1:2) {
        # hyperpriors
        mu_d1[g] ~ dnorm(0, 0.25)
        mu_c[g] ~ dnorm(0, 0.25)
        sigma_d1[g] ~ dnorm(0, 0.25) I(0, )
        sigma_c[g] ~ dnorm(0, 0.25) I(0, )
        lambda_d1[g] <- pow(sigma_d1[g], -2)
        lambda_c[g] <- pow(sigma_c[g], -2)

        mu_cS1[g] ~ dnorm(0, 0.25)
        mu_cS2[g] ~ dnorm(0, 0.25)
        sigma_cS1[g] ~ dnorm(0, 0.25) I(0, )
        sigma_cS2[g] ~ dnorm(0, 0.25) I(0, )
        lambda_cS1[g] <- pow(sigma_cS1[g], -2)
        lambda_cS2[g] <- pow(sigma_cS2[g], -2)

        mu_Mratio[g] ~ dunif(0,4)
        sigma_delta[g] ~ dnorm(0,0.25) I(0,)
        lambda_delta[g] <- pow(sigma_delta[g], -2)
        epsilon_Mratio[g] ~ dbeta(1,1)
        sigma_Mratio[g] <- abs(epsilon_Mratio[g])*sigma_delta[g]
    }
    diff_mu_Mratio <- mu_Mratio[2] - mu_Mratio[1]
}